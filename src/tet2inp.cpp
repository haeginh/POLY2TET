#include "tet2inp.hpp"
#include <stdlib.h>
#include <algorithm>
#include <iterator>
#include <sstream>
#include <iomanip>

template <typename T>
vector<size_t> tet2inp::sort_indexes(const vector<T> &v) {

	// initialize original index locations
	vector<size_t> idx(v.size());
	for (size_t i = 0; i != idx.size(); ++i) idx[i] = i;

	// sort indexes based on comparing values in v
	sort(idx.begin(), idx.end(),
		[&v](size_t i1, size_t i2) {return v[i1] < v[i2]; });

	return idx;
}

void tet2inp::ReplaceStringInPlace(std::string& subject, const std::string& search,	const std::string& replace) {
	size_t pos = 0;
	while ((pos = subject.find(search, pos)) != std::string::npos) {
		subject.replace(pos, search.length(), replace);
		pos += replace.length();
	}
}

// For TET2INP conversion
tet2inp::tet2inp(string inp_filename, string out_filename, vector<ThreeVector> node_vec)
:node_vector(node_vec)
{
	string filename_ele = inp_filename;
	string filename_out = out_filename;

	ifstream ifp_ele;

	ifp_ele.open(filename_ele.c_str());

	if (!ifp_ele.is_open())
	{
		cerr << filename_ele << " file open ERROR!!!" << endl;
		return;
	}

	int temp_int;
	int ele_num;

	ifp_ele >> ele_num;
	ifp_ele >> temp_int >> temp_int;

	cout << "Loading *.ele file..." << flush;
	for(int i=0;i<ele_num;i++)
	{
		ifp_ele >> temp_int;
		int a, b, c, d;
		ifp_ele >> a>>b>>c>>d;
        ELE ele;
        ele = ELE(a, b, c, d);

        ifp_ele >> temp_int;	//	 Region information

		ele_map[temp_int].push_back(ele);
	}
	ifp_ele.close(); cout<<"done"<<endl;

	newele_map.clear();
	double tet_volume(0);

	int organIdx = 0;
	for (auto ele_iter : ele_map)
	{
		cout <<'\r'<<"Arranging parts of tetrahedral-mesh model... "<< ++organIdx << " / " << ele_map.size() << flush;
		int organID = ele_iter.first;
		map<int, int> whole2ext;
		int n1, n2, n3, n4;
		int nodeID(0);
		double totVol6(0.);
		for(auto ele:ele_iter.second){
			// arrange node ID
			tie(n1, n2, n3, n4) = ele;
			if(whole2ext.insert(make_pair(n1, nodeID)).second) nodeID++;
			if(whole2ext.insert(make_pair(n2, nodeID)).second) nodeID++;
			if(whole2ext.insert(make_pair(n3, nodeID)).second) nodeID++;
			if(whole2ext.insert(make_pair(n4, nodeID)).second) nodeID++;

			// add tet vol.
			ThreeVector fV21 = node_vector[n2] - node_vector[n1];
			ThreeVector fV31 = node_vector[n3] - node_vector[n1];
			ThreeVector fV41 = node_vector[n4] - node_vector[n1];
			double signed_vol = fV21.cross(fV31).dot(fV41);
			totVol6 += std::fabs(signed_vol);
		}
		vol_map[organID] = totVol6 / 6.;

		// set new maps for node/ele
		for(auto iter:whole2ext)
			node_map[organID].push_back(node_vector[iter.first]);

		for(auto ele:ele_iter.second){
			tie(n1, n2, n3, n4) = ele;
			newele_map[organID].push_back(ELE(whole2ext[n1]+1, whole2ext[n2]+1, whole2ext[n3]+1, whole2ext[n4]+1));
		}
	}
	cout << endl << "Converting TET to MCNP..." << flush;
	convertToINP(filename_out);
	cout << "done" << endl;
}

tet2inp::~tet2inp(void)
{
	
}

void tet2inp::convertToINP(string filename)
{
	stringstream ss;
    //////////------------------Heading information----------------------/////////
	ss<<"*Heading"<<endl;
    ss<<"** Job name: Making_tetrahedron_phantom Model name: " << filename <<endl;
    ss<<"** Generated by: TET2MCNPinp"<<endl;
    ss<<"*Preprint, echo=NO, model=NO, history=NO, contact=NO"<<endl;
    ss<<"**"<<endl;
    ss<<"** PARTS"<<endl;
    ss<<"**"<<endl;
	///////////////////////////////////////////////////////////////////////////////
	ss.precision( 5 );
	ss.setf(ios_base:: fixed, ios_base:: floatfield);
	
	for(auto node_iter: node_map)
	{
		int part_idx = node_iter.first;
		ss << "*Part, name=Part-"<< part_idx <<endl;
		ss << "*Node"<<endl;
		int i = 0;
		for (auto point_iter: node_iter.second)
		{			
			char id[80];
			sprintf(id, "%d,  %.10f, %.10f, %.10f", ++i, point_iter.getX(), point_iter.getY(), point_iter.getZ());
			ss << id << endl;
		}
		ss << "*Element, type=C3D4"<<endl;
		i = 0;
		int n1, n2, n3, n4;
		for (auto ele_iter: newele_map[part_idx])
		{
			tie(n1, n2, n3, n4) = ele_iter;
			ss << ++i <<",  "<< n1 <<",  " << n2 <<",  " << n3<<",  "<< n4<<endl;
		}
		ss<<"*Nset, nset=Set-material_"<< part_idx  <<", generate"<<endl;
		ss<<"1,   "<< node_iter.second.size()<<",   1"<<endl;
		ss<<"*Elset, elset=Set-material_"<< part_idx <<", generate"<<endl;
		ss<<"1,   "<< newele_map[part_idx].size()<<",   1"<<endl;
		ss<<"*Nset, nset=Set-statistic_"<< part_idx  <<", generate"<<endl;
		ss<<"1,   "<< node_iter.second.size()<<",   1"<<endl;
		ss<<"*Elset, elset=Set-statistic_"<< part_idx  <<", generate"<<endl;
		ss<<"1,   "<< newele_map[part_idx].size()<<",   1"<<endl;
		ss<<"*End Part "<<endl;
		ss<<"**"<<endl;
	}


	/////////////////////writing assembly information////////////////////
	ss<<"** ASSEMBLY"<<endl;
	ss<<"**"<<endl;
	ss<<"*Assembly, name=Assembly"<<endl;
	ss<<"**"<<endl;
	for (auto node_iter : node_map)
	{
		int idx = node_iter.first;
		ss<<"*Instance, name=Part-"<<idx<<"-1"<<", part=Part-"<<idx<<endl;
		ss<<"*End Instance"<<endl;
		ss<<"**"<<endl;
	}
	ss<<"*End Assembly"<<endl;
	ss<<"**"<<endl;
	ss<<"** MATERIALS"<<endl;
	ss<<"**"<<endl;
	int before = 0;
	for (auto node_iter : node_map)
	{
		int part_idx = node_iter.first;
		if (before != part_idx) {
			before = part_idx;
			ss << "*Material, name=Material_" << part_idx << endl;
		}
	}
	ofstream  ofs(filename,ios::out);
	ofs<<ss.str();
	ofs.close();
}

void tet2inp::PrintCell(string filename, map<int, double> densityMap){
	ofstream  ofs(filename,ios::out);
	ofs<<"C PSUEDO CELLS FOR ABAQUS"<<endl;
	int w = floor((double)(log10(vol_map.rbegin()->first)))+1;
	ofs<<fixed;
	for(auto vol:vol_map){
		ofs<<" "<<setfill('0')<<setw(w)<<vol.first<<" "<<setfill(' ')<<setw(w)<<vol.first;
		ofs.precision(4);
		ofs<<setw(9)<<fixed<<densityMap[vol.first]<<"  0  u=2 ";
		ofs.precision(9);
		ofs<<"vol="<<vol.second<<endl;
	}
	ofs<<" 99999     0      0  u=2 "<<endl;
	ofs<<"c -----------------------------------------------";
	ofs.close();
}

void tet2inp::PrintTally(string filename, map<int, string> matNameMap){
	int w = floor((double)(log10(vol_map.rbegin()->first)));
	ofstream ofs(filename, ios::out);
	ofs<<"C TALLIES FOR EACH ORGAN/TISSUE"<<endl;
	for(auto vol:vol_map){
		ofs<<setw(w+5)<<left<<"+f"+to_string(vol.first)+"6"
		   <<setw(w+2)<<"( " + to_string(vol.first) << " ) $"+matNameMap[vol.first]<<endl;
	}
	ofs<<"C";
	ofs.close();
}

/*
void tet2inp::makeMCNPinp(string out_filename, string mat_file)
{	
	ofstream ofp;
	string MCNP_input = out_filename.substr(0, out_filename.size() - 3) + "mcnpinp";

	ofp.open(MCNP_input);
	
	ofp << "No description for this unstructured mesh file" << endl;
	ofp << "c" << endl;
	ofp << "c  Created from file    : " << out_filename <<endl;
	ofp << "c  Created on           : " << currentDateTime()<<endl;
	ofp << "c  Created by           : TET2MCNP" << endl;
	ofp << "c" << endl;
	
	ifstream ifp;
	bool mat_info = !(mat_file.empty());
	map<int, double> density_map;
	if (mat_info)
	{
		ifp.open(mat_file.c_str());
		if (!ifp.is_open()) {
			cerr << mat_file  << " file open ERROR!!!" << endl;
			return;
		}
		int tempInt;
		double tempDbl;
		for (int i = 0;; i++)
		{
			ifp >> tempInt >> tempDbl;
			if (tempInt == -2) break;
			density_map[tempInt] = tempDbl;
		}
		ifp.close();
	}

	//---------------------------------------//
	ofp << "c PSEUDO CELLS" << endl;
	char id[80];
	int i = 0;
	for(auto node_iter : node_map)
	{		
		int idx = node_iter.first;
		if(mat_info) sprintf(id,"%03d   %4d    %.10f      0  u=2  vol=%.10f",++i,idx,density_map[idx], vol_map[node_iter.first]);
		else sprintf(id, "%03d   %4d    %.10f      0  u=2  vol=%.10f", ++i, idx, 0.00, vol_map[node_iter.first]);
		ofp << id << endl;
	}
	int max = node_map.size();
	sprintf(id,"%03d   %4d                 0  u=2",max+1 ,0);		// background
	ofp << id << endl;
	ofp << "c" << endl;
	
	
		
	//---------------------------------------//
	ofp << "c LEGACY CELLS" << endl;

	sprintf(id,"%03d   %4d                 -99999  fill =2",max+2 ,0);
	ofp << id << endl;
	sprintf(id,"%03d   %4d                  99999",max+3 ,0);
	ofp << id << endl;
	
	ofp << endl<< "c" << endl;

	
	//---------------------------------------//
	ofp << "c SURFACES" << endl;

	sprintf(id,"99999   sph  0       0       0       %.10f",max_r);
	ofp << id << endl;	
	ofp << endl<< "c" << endl;


	//---------------------------------------//
	ofp << "c DATA CARDS" << endl;
	ofp << "embed2 meshgeo=abaqus" << endl;
    ofp << "       mgeoin=" << MCNP_input << "inp" << endl;
    ofp << "       meeout=" << MCNP_input << "eeout" << endl;
	ofp << "       filetype=ascii" << endl;
	ofp << "       gmvfile=" << MCNP_input << "gmvfile" << endl;
    ofp << "       background=      " << max+1 << endl;
	ofp << "       matcell= ";
	i = 0;
	for (auto node_iter : node_map)
	{
		int idx = node_iter.first;
		if(i%5==0 && i!=0) ofp << endl << "                ";
		i++;
		sprintf(id,"%4d %4d  ", i, i);
		ofp << id;	
	}
	ofp << endl;
	ofp << "c" << endl;

	int tallyID = 0;
	int before = 0;
	int index = 0;
	int idx = 0;
	int cellID = 0;
	for (auto node_iter : node_map)
	{		
		idx = node_iter.first;
		if(idx != before){
			if (before != 0) {
				ofp << ")" << endl;
				ofp << "c" << endl;
			}
			sprintf(id, "+f%03d6  ", idx);
			ofp << id;
			before = idx;
			index = 0;
		}		
		if (index == 0) sprintf(id, "(%4d ", ++cellID);
		else sprintf(id, "%4d ", ++cellID);
		if (index % 10 == 0 && index != 0) ofp << endl << "        ";
		index++;
				
		ofp << id;
	}
	ofp << ")" << endl;
	ofp << "c" << endl;
			
	ofp.close();
}

*/
const string tet2inp::currentDateTime() {
    time_t     now = time(0); 
    struct tm  tstruct;
    char       buf[80];
    tstruct = *localtime(&now);
    strftime(buf, sizeof(buf), "%Y-%m-%d.%X", &tstruct); // YYYY-MM-DD.HH:mm:ss 

    return buf;
}


